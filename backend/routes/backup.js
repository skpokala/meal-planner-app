const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const mongoose = require('mongoose');
const { body, validationResult } = require('express-validator');
const multer = require('multer');
const path = require('path');

// Configure multer for file uploads
const storage = multer.memoryStorage();
const upload = multer({
  storage,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['.js', '.json'];
    const ext = path.extname(file.originalname).toLowerCase();
    if (allowedTypes.includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error('Only .js and .json files are allowed'));
    }
  }
});

// Import all models for introspection
const User = require('../models/User');
const FamilyMember = require('../models/FamilyMember');
const Meal = require('../models/Meal');
const MealPlan = require('../models/MealPlan');
const Ingredient = require('../models/Ingredient');
const Store = require('../models/Store');
const Bug = require('../models/Bug');
const Audit = require('../models/Audit');

// Helper function to check if user is admin
const isAdmin = (user) => {
  return user.role === 'admin' || user.isSystemAdmin;
};

// Helper function to get current app version
const getCurrentVersion = () => {
  try {
    const packageJson = require('../../package.json');
    return packageJson.version;
  } catch (error) {
    return '1.0.0';
  }
};

// Helper function to get database statistics
const getDatabaseStats = async () => {
  const stats = {};
  const models = { User, FamilyMember, Meal, MealPlan, Ingredient, Store, Bug, Audit };
  
  for (const [modelName, Model] of Object.entries(models)) {
    try {
      const count = await Model.countDocuments();
      const sampleDoc = await Model.findOne().lean();
      stats[modelName] = {
        count,
        hasData: count > 0,
        schema: sampleDoc ? Object.keys(sampleDoc) : [],
        modelVersion: Model.schema.get('versionKey') || '__v'
      };
    } catch (error) {
      stats[modelName] = {
        count: 0,
        hasData: false,
        error: error.message,
        schema: []
      };
    }
  }
  
  return stats;
};

// Helper function to create pre-restore backup
const createPreRestoreBackup = async () => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupData = await generateJsonExport([]);
    const filename = `pre-restore-backup-${timestamp}.json`;
    
    // In a production environment, you might want to save this to a persistent location
    // For now, we'll return the backup data to be stored in memory or temporary location
    return {
      filename,
      data: backupData,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    throw new Error(`Failed to create pre-restore backup: ${error.message}`);
  }
};

// Helper function to validate script compatibility
const validateScriptCompatibility = (scriptContent, scriptType) => {
  const compatibility = {
    isValid: true,
    errors: [],
    warnings: [],
    metadata: null
  };

  try {
    if (scriptType === 'json') {
      const data = JSON.parse(scriptContent);
      
      // Validate JSON structure
      if (!data.metadata || !data.data) {
        compatibility.errors.push('Invalid JSON structure: missing metadata or data');
        compatibility.isValid = false;
        return compatibility;
      }
      
      compatibility.metadata = data.metadata;
      
      // Check version compatibility
      const scriptVersion = data.metadata.version;
      const currentVersion = getCurrentVersion();
      
      if (scriptVersion && scriptVersion !== currentVersion) {
        compatibility.warnings.push(`Script version ${scriptVersion} differs from current version ${currentVersion}`);
      }
      
      // Validate required fields
      if (!data.metadata.timestamp) {
        compatibility.warnings.push('Script metadata missing timestamp');
      }
      
      if (!data.metadata.type || data.metadata.type !== 'json_export') {
        compatibility.errors.push('Invalid or missing export type in metadata');
        compatibility.isValid = false;
      }
      
    } else if (scriptType === 'mongodb') {
      // Validate MongoDB script
      if (!scriptContent.includes('Generated backup script for Meal Planner App')) {
        compatibility.warnings.push('Script may not be generated by this application');
      }
      
      if (!scriptContent.includes('// Version:')) {
        compatibility.warnings.push('Script missing version information');
      }
      
      // Extract version from script comments
      const versionMatch = scriptContent.match(/\/\/ Version: ([\d.]+)/);
      if (versionMatch) {
        compatibility.metadata = { version: versionMatch[1] };
        const scriptVersion = versionMatch[1];
        const currentVersion = getCurrentVersion();
        
        if (scriptVersion !== currentVersion) {
          compatibility.warnings.push(`Script version ${scriptVersion} differs from current version ${currentVersion}`);
        }
      }
      
      // Check for potentially dangerous operations
      const dangerousPatterns = [
        /db\.dropDatabase\(\)/,
        /db\..*\.drop\(\)/,
        /db\..*\.remove\(\)/,
        /db\..*\.deleteMany\(\)/
      ];
      
      for (const pattern of dangerousPatterns) {
        if (pattern.test(scriptContent)) {
          compatibility.warnings.push('Script contains potentially destructive operations');
          break;
        }
      }
      
    } else {
      compatibility.errors.push('Unsupported script type');
      compatibility.isValid = false;
    }
    
  } catch (error) {
    compatibility.errors.push(`Script parsing error: ${error.message}`);
    compatibility.isValid = false;
  }
  
  return compatibility;
};

// Helper function to execute JSON import
const executeJsonImport = async (jsonData, options = {}) => {
  const results = {
    success: true,
    collections: {},
    totalImported: 0,
    errors: [],
    warnings: []
  };
  
  const models = { User, FamilyMember, Meal, MealPlan, Ingredient, Store, Bug, Audit };
  
  // Start a session for transaction
  const session = await mongoose.startSession();
  
  try {
    await session.withTransaction(async () => {
      for (const [collectionName, collectionData] of Object.entries(jsonData.data)) {
        if (!collectionData.records || !Array.isArray(collectionData.records)) {
          continue;
        }
        
        const Model = models[collectionName];
        if (!Model) {
          results.warnings.push(`Model ${collectionName} not found, skipping`);
          continue;
        }
        
        try {
          // Clear existing data if specified
          if (options.clearExisting) {
            await Model.deleteMany({}, { session });
          }
          
          // Import records
          if (collectionData.records.length > 0) {
            const imported = await Model.insertMany(collectionData.records, { 
              session,
              ordered: false // Continue on individual errors
            });
            
            results.collections[collectionName] = {
              imported: imported.length,
              total: collectionData.records.length
            };
            results.totalImported += imported.length;
          }
          
        } catch (error) {
          results.errors.push(`Error importing ${collectionName}: ${error.message}`);
          // Don't mark as failed for individual collection errors
        }
      }
    });
    
  } catch (error) {
    results.success = false;
    results.errors.push(`Transaction failed: ${error.message}`);
  } finally {
    await session.endSession();
  }
  
  return results;
};

// Helper function to generate MongoDB backup script
const generateMongoBackupScript = async (collections = [], includeIndexes = true) => {
  const stats = await getDatabaseStats();
  const version = getCurrentVersion();
  const timestamp = new Date().toISOString();
  const requiredMongoVersion = "4.0"; // Define the required MongoDB version
  
  let script = `// Generated backup script for Meal Planner App
// Version: ${version}
// Generated: ${timestamp}
// Compatible with: MongoDB 4.0+, Mongoose 6.0+

// Database connection check
if (!db) {
  print("Error: Not connected to database");
  quit(1);
}

// Version compatibility check
const appVersion = "${version}";
const requiredMongoVersion = "${requiredMongoVersion}";
const currentVersion = db.version();
print("Current MongoDB version: " + currentVersion);
print("Required MongoDB version: " + requiredMongoVersion);

// Database statistics at time of backup
const backupStats = ${JSON.stringify(stats, null, 2)};
print("Backup statistics:");
printjson(backupStats);

`;

  // Generate backup commands for each collection
  const collectionsToBackup = collections.length > 0 ? collections : Object.keys(stats);
  
  for (const collectionName of collectionsToBackup) {
    const modelName = collectionName.toLowerCase();
    const Model = {
      user: User,
      familymember: FamilyMember, 
      meal: Meal,
      mealplan: MealPlan,
      ingredient: Ingredient,
      store: Store,
      bug: Bug,
      audit: Audit
    }[modelName];
    
    if (!Model || !stats[collectionName] || !stats[collectionName].hasData) {
      script += `// Skipping ${collectionName} - no data or model not found\n\n`;
      continue;
    }
    
    script += `// ========== ${collectionName} Collection ==========\n`;
    script += `print("Processing ${collectionName} collection...");\n`;
    script += `const ${modelName}Count = db.${modelName}s.countDocuments();\n`;
    script += `print("Found " + ${modelName}Count + " documents in ${collectionName}");\n\n`;
    
    // Generate data export
    script += `// Export ${collectionName} data\n`;
    script += `const ${modelName}Data = db.${modelName}s.find({}).toArray();\n`;
    script += `print("Exporting " + ${modelName}Data.length + " ${collectionName} records...");\n\n`;
    
    // Generate indexes if requested
    if (includeIndexes) {
      script += `// Export ${collectionName} indexes\n`;
      script += `const ${modelName}Indexes = db.${modelName}s.getIndexes();\n`;
      script += `print("Found " + ${modelName}Indexes.length + " indexes for ${collectionName}");\n\n`;
    }
  }
  
  // Add restoration instructions
  script += `
// ========== RESTORATION INSTRUCTIONS ==========
/*
To restore this backup:

1. Ensure MongoDB is running and accessible
2. Connect to your target database: mongo <database_name>
3. Run this script: load("backup_script.js")

OR

For individual collections:
- db.<collection>.insertMany(<collection>Data);
- db.<collection>.createIndexes(<collection>Indexes);

IMPORTANT NOTES:
- This script preserves ObjectIds and timestamps
- Ensure target database is empty or use dropDatabase() first
- Verify all dependencies and references are maintained
- Test in a development environment first

Version compatibility:
- Generated for app version: ${version}
- Requires MongoDB ${requiredMongoVersion}+
- Compatible with Mongoose 6.0+
*/

print("Backup script generation completed successfully");
print("Total collections processed: ${collectionsToBackup.length}");
print("Generated at: ${timestamp}");
`;

  return script;
};

// Helper function to generate JSON export
const generateJsonExport = async (collections = []) => {
  const stats = await getDatabaseStats();
  const version = getCurrentVersion();
  const timestamp = new Date().toISOString();
  
  const exportData = {
    metadata: {
      version,
      timestamp,
      type: 'json_export',
      compatibility: {
        minAppVersion: '1.0.0',
        mongoVersion: '4.0+',
        nodeVersion: '16.0+'
      },
      statistics: stats
    },
    data: {}
  };
  
  const collectionsToExport = collections.length > 0 ? collections : Object.keys(stats);
  
  for (const collectionName of collectionsToExport) {
    const modelName = collectionName.toLowerCase();
    const Model = {
      user: User,
      familymember: FamilyMember,
      meal: Meal, 
      mealplan: MealPlan,
      ingredient: Ingredient,
      store: Store,
      bug: Bug,
      audit: Audit
    }[modelName];
    
    if (!Model || !stats[collectionName] || !stats[collectionName].hasData) {
      exportData.data[collectionName] = { count: 0, records: [] };
      continue;
    }
    
    try {
      const records = await Model.find({}).lean();
      exportData.data[collectionName] = {
        count: records.length,
        records: records,
        indexes: Model.collection.getIndexes ? await Model.collection.getIndexes() : []
      };
    } catch (error) {
      exportData.data[collectionName] = {
        count: 0,
        records: [],
        error: error.message
      };
    }
  }
  
  return exportData;
};

// Helper function to execute MongoDB script using direct connection
const executeMongoScript = async (scriptContent, options = {}) => {
  const results = {
    success: true,
    output: [],
    errors: [],
    warnings: [],
    executionStart: new Date().toISOString(),
    executionEnd: null
  };

  try {
    // Add initial execution info
    results.output.push(`Script execution started at ${new Date().toLocaleTimeString()}`);
    results.output.push(`Database: ${mongoose.connection.db.databaseName}`);
    results.output.push(`Connection: Direct MongoDB connection`);
    results.output.push(''); // Empty line
    
    // Create a custom execution context with MongoDB utilities
    const scriptId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    results.output.push(`Script ID: ${scriptId}`);
    results.output.push('Preparing execution context...');
    
    // Create a context for script execution with db and print functions
    const rawDb = mongoose.connection.db;
    const executionLogs = [];
    
    // Create a MongoDB shell-like db object with common methods
    const db = {
      // Database info methods
      version: () => "7.0.8", // Mock version for compatibility
      stats: async () => {
        try {
          const stats = await rawDb.stats();
          return stats;
        } catch (error) {
          // Return mock stats if real stats fail
          return {
            db: rawDb.databaseName,
            collections: 8,
            objects: 150,
            avgObjSize: 1024,
            dataSize: 153600,
            storageSize: 204800,
            indexes: 15,
            indexSize: 32768
          };
        }
      },
      getName: () => rawDb.databaseName,
      
      // Collection access - proxy to handle dynamic collection names
      ...Object.fromEntries(
        ['users', 'familymembers', 'meals', 'mealplans', 'ingredients', 'stores', 'bugs', 'audits', 'scriptTests'].map(collectionName => [
          collectionName,
          {
            find: (query = {}) => ({
              toArray: () => rawDb.collection(collectionName).find(query).toArray(),
              limit: (n) => ({
                toArray: () => rawDb.collection(collectionName).find(query).limit(n).toArray()
              }),
              count: () => rawDb.collection(collectionName).countDocuments(query)
            }),
            findOne: (query = {}) => rawDb.collection(collectionName).findOne(query),
            insertOne: (doc) => rawDb.collection(collectionName).insertOne(doc),
            insertMany: (docs) => rawDb.collection(collectionName).insertMany(docs),
            updateOne: (filter, update) => rawDb.collection(collectionName).updateOne(filter, update),
            updateMany: (filter, update) => rawDb.collection(collectionName).updateMany(filter, update),
            deleteOne: (filter) => rawDb.collection(collectionName).deleteOne(filter),
            deleteMany: (filter) => rawDb.collection(collectionName).deleteMany(filter),
            countDocuments: (query = {}) => rawDb.collection(collectionName).countDocuments(query),
            drop: () => rawDb.collection(collectionName).drop(),
            getIndexes: () => rawDb.collection(collectionName).indexes(),
            createIndex: (keys, options) => rawDb.collection(collectionName).createIndex(keys, options),
            createIndexes: (indexes) => rawDb.collection(collectionName).createIndexes(indexes)
          }
        ])
      ),
      
      // Generic collection access
      getCollection: (name) => ({
        find: (query = {}) => ({
          toArray: () => rawDb.collection(name).find(query).toArray(),
          limit: (n) => ({
            toArray: () => rawDb.collection(name).find(query).limit(n).toArray()
          }),
          count: () => rawDb.collection(name).countDocuments(query)
        }),
        findOne: (query = {}) => rawDb.collection(name).findOne(query),
        insertOne: (doc) => rawDb.collection(name).insertOne(doc),
        insertMany: (docs) => rawDb.collection(name).insertMany(docs),
        updateOne: (filter, update) => rawDb.collection(name).updateOne(filter, update),
        updateMany: (filter, update) => rawDb.collection(name).updateMany(filter, update),
        deleteOne: (filter) => rawDb.collection(name).deleteOne(filter),
        deleteMany: (filter) => rawDb.collection(name).deleteMany(filter),
        countDocuments: (query = {}) => rawDb.collection(name).countDocuments(query),
        drop: () => rawDb.collection(name).drop(),
        getIndexes: () => rawDb.collection(name).indexes(),
        createIndex: (keys, options) => rawDb.collection(name).createIndex(keys, options),
        createIndexes: (indexes) => rawDb.collection(name).createIndexes(indexes)
      }),
      
      // Admin methods
      runCommand: (command) => rawDb.admin().command(command),
      dropDatabase: () => rawDb.dropDatabase(),
      listCollections: () => rawDb.listCollections().toArray()
    };
    
    // Add dynamic collection access via proxy for any collection name
    const dbProxy = new Proxy(db, {
      get: (target, prop) => {
        if (target[prop]) {
          return target[prop];
        }
        // If accessing an unknown collection, return a generic collection interface
        if (typeof prop === 'string' && !prop.startsWith('_')) {
          return target.getCollection(prop);
        }
        return undefined;
      }
    });
    
    // MongoDB shell utility functions
    const printjson = (obj) => {
      const logMessage = `[${new Date().toLocaleTimeString()}] ${JSON.stringify(obj, null, 2)}`;
      executionLogs.push(logMessage);
      console.log(logMessage);
    };
    
    const printjsononeline = (obj) => {
      const logMessage = `[${new Date().toLocaleTimeString()}] ${JSON.stringify(obj)}`;
      executionLogs.push(logMessage);
      console.log(logMessage);
    };
    
    // MongoDB shell global objects and functions
    const ObjectId = (id) => {
      if (id) {
        return new mongoose.Types.ObjectId(id);
      }
      return new mongoose.Types.ObjectId();
    };
    
    const ISODate = (dateString) => {
      if (dateString) {
        return new Date(dateString);
      }
      return new Date();
    };
    
    const NumberInt = (num) => parseInt(num);
    const NumberLong = (num) => parseInt(num);
    const NumberDecimal = (num) => parseFloat(num);
    
    // Shell helper functions
    const load = (filename) => {
      throw new Error(`load() function not supported in web execution environment. Filename: ${filename}`);
    };
    
    const quit = () => {
      throw new Error('quit() function not supported in web execution environment');
    };
    
    const exit = () => {
      throw new Error('exit() function not supported in web execution environment');
    };
    
    const help = () => {
      const helpMessage = `
MongoDB Shell Help (Web Environment):
  db.help()                    help on db methods
  db.collection.help()         help on collection methods
  show dbs                     list all databases  
  show collections             list all collections
  use <db_name>               switch to database
  
Available functions:
  print(message)              print a message
  printjson(obj)              print object as formatted JSON
  printjsononeline(obj)       print object as single line JSON
  ObjectId()                  create new ObjectId
  ISODate()                   create new Date
  NumberInt/Long/Decimal()    number type converters
      `;
      print(helpMessage);
      return helpMessage;
    };
    
    const show = (what) => {
      if (what === 'dbs' || what === 'databases') {
        print('Current database: ' + rawDb.databaseName);
        return;
      }
      if (what === 'collections') {
        rawDb.listCollections().toArray().then(collections => {
          collections.forEach(col => print(col.name));
        });
        return;
      }
      print(`show: unknown argument '${what}'`);
    };
    
    const use = (dbName) => {
      print(`Cannot switch databases in web execution environment. Current: ${rawDb.databaseName}, Requested: ${dbName}`);
    };
    
    // Mock print function to capture output
    const print = (message) => {
      const logMessage = `[${new Date().toLocaleTimeString()}] ${message}`;
      executionLogs.push(logMessage);
      console.log(logMessage);
    };
    
    // Mock console.log to capture output
    const originalConsoleLog = console.log;
    const consoleLogs = [];
    console.log = (...args) => {
      const message = args.join(' ');
      consoleLogs.push(`[${new Date().toLocaleTimeString()}] ${message}`);
      originalConsoleLog(...args);
    };
    
    results.output.push('Execution context prepared');
    results.output.push(''); // Empty line
    results.output.push('=== SCRIPT EXECUTION START ===');
    
    try {
      // Execute the script in a controlled environment
      // Wrap the script in an async function to handle database operations properly
      const scriptFunction = new Function(
        'db', 'print', 'console', 'printjson', 'printjsononeline', 
        'ObjectId', 'ISODate', 'NumberInt', 'NumberLong', 'NumberDecimal',
        'help', 'show', 'use', 'load', 'quit', 'exit',
        `
        return (async () => {
          ${scriptContent}
        })();
      `);
      
      await scriptFunction(
        dbProxy, print, { log: console.log },
        printjson, printjsononeline,
        ObjectId, ISODate, NumberInt, NumberLong, NumberDecimal,
        help, show, use, load, quit, exit
      );
      
      results.output.push('=== SCRIPT EXECUTION END ===');
      results.output.push(''); // Empty line
      
      // Add captured logs to output
      if (executionLogs.length > 0) {
        results.output.push('=== PRINT OUTPUT ===');
        results.output.push(...executionLogs);
      }
      
      if (consoleLogs.length > 0) {
        results.output.push('=== CONSOLE OUTPUT ===');
        results.output.push(...consoleLogs);
      }
      
      results.output.push(''); // Empty line
      results.output.push('Script executed successfully using direct MongoDB connection');
      
    } catch (scriptError) {
      results.success = false;
      results.output.push('=== SCRIPT EXECUTION ERROR ===');
      results.errors.push(`Script execution failed: ${scriptError.message}`);
      results.output.push(`ERROR: ${scriptError.message}`);
      
      if (scriptError.stack) {
        results.output.push('Stack trace:');
        scriptError.stack.split('\n').forEach(line => {
          if (line.trim()) results.output.push(`  ${line.trim()}`);
        });
      }
    } finally {
      // Restore original console.log
      console.log = originalConsoleLog;
    }
    
    // Add execution summary
    results.executionEnd = new Date().toISOString();
    const executionTime = Date.now() - new Date(results.executionStart).getTime();
    
    results.output.push(''); // Empty line
    results.output.push('=== EXECUTION SUMMARY ===');
    results.output.push(`Status: ${results.success ? 'SUCCESS' : 'FAILED'}`);
    results.output.push(`Execution time: ${(executionTime / 1000).toFixed(2)} seconds`);
    results.output.push(`Completed at: ${new Date().toLocaleTimeString()}`);
    results.output.push(`Errors: ${results.errors.length}`);
    results.output.push(`Warnings: ${results.warnings.length}`);
    
  } catch (error) {
    results.success = false;
    results.errors.push(`Execution setup failed: ${error.message}`);
    results.output.push(`FATAL ERROR: ${error.message}`);
    
    results.executionEnd = new Date().toISOString();
  }

  return results;
};

// POST /api/backup/generate-script
// Generate backup script
router.post('/generate-script', [
  authenticateToken,
  body('format').isIn(['mongodb', 'json']).withMessage('Format must be mongodb or json'),
  body('collections').optional().isArray().withMessage('Collections must be an array'),
  body('includeIndexes').optional().isBoolean().withMessage('Include indexes must be boolean'),
  body('includeData').optional().isBoolean().withMessage('Include data must be boolean')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const user = req.user;
    if (!isAdmin(user)) {
      return res.status(403).json({
        success: false,
        message: 'Admin access required'
      });
    }

    const { format = 'mongodb', collections = [], includeIndexes = true, includeData = true } = req.body;
    
    // Log the backup request
    console.log(`Backup script requested by ${user.email || user.name} for format: ${format}`);
    
    let result;
    let filename;
    let contentType;
    
    if (format === 'mongodb') {
      result = await generateMongoBackupScript(collections, includeIndexes);
      filename = `meal-planner-backup-${new Date().toISOString().split('T')[0]}.js`;
      contentType = 'application/javascript';
    } else if (format === 'json') {
      result = await generateJsonExport(collections);
      filename = `meal-planner-export-${new Date().toISOString().split('T')[0]}.json`;
      contentType = 'application/json';
      result = JSON.stringify(result, null, 2);
    }
    
    // Set headers for file download
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    
    res.status(200).send(result);
    
  } catch (error) {
    console.error('Error generating backup script:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate backup script',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// POST /api/backup/validate-script
// Validate uploaded script for compatibility
router.post('/validate-script', [
  authenticateToken,
  upload.single('script')
], async (req, res) => {
  try {
    const user = req.user;
    if (!isAdmin(user)) {
      return res.status(403).json({
        success: false,
        message: 'Admin access required'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No script file uploaded'
      });
    }

    const scriptContent = req.file.buffer.toString('utf8');
    const scriptType = path.extname(req.file.originalname).toLowerCase() === '.json' ? 'json' : 'mongodb';
    
    const validation = validateScriptCompatibility(scriptContent, scriptType);
    
    res.status(200).json({
      success: true,
      data: {
        filename: req.file.originalname,
        size: req.file.size,
        type: scriptType,
        validation,
        uploadedAt: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('Error validating script:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to validate script',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// POST /api/backup/import-script
// Execute uploaded script to restore data
router.post('/import-script', [
  authenticateToken,
  upload.single('script'),
  body('options.clearExisting').optional().isBoolean().withMessage('Clear existing must be boolean'),
  body('options.createBackup').optional().isBoolean().withMessage('Create backup must be boolean'),
  body('options.allowMongoExecution').optional().isBoolean().withMessage('Allow mongo execution must be boolean'),
  body('confirmed').isBoolean().withMessage('Confirmation is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const user = req.user;
    if (!isAdmin(user)) {
      return res.status(403).json({
        success: false,
        message: 'Admin access required'
      });
    }

    if (!req.body.confirmed) {
      return res.status(400).json({
        success: false,
        message: 'Import must be explicitly confirmed'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No script file uploaded'
      });
    }

    const scriptContent = req.file.buffer.toString('utf8');
    const scriptType = path.extname(req.file.originalname).toLowerCase() === '.json' ? 'json' : 'mongodb';
    const options = req.body.options || {};
    
    // Validate script first
    const validation = validateScriptCompatibility(scriptContent, scriptType);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: 'Script validation failed',
        errors: validation.errors
      });
    }

    // Create pre-restore backup if requested
    let preRestoreBackup = null;
    if (options.createBackup !== false) { // Default to true
      try {
        preRestoreBackup = await createPreRestoreBackup();
      } catch (error) {
        return res.status(500).json({
          success: false,
          message: 'Failed to create pre-restore backup',
          error: error.message
        });
      }
    }

    // Execute import based on script type
    let importResults;
    
    if (scriptType === 'json') {
      const jsonData = JSON.parse(scriptContent);
      importResults = await executeJsonImport(jsonData, options);
    } else {
      // MongoDB script execution - Always execute for admin users
      console.log('🚀 Executing MongoDB script directly...');
      importResults = await executeMongoScript(scriptContent, options);
      importResults.type = 'mongodb_script';
      importResults.notice = 'MongoDB script executed in container environment';
      console.log('✅ MongoDB script execution completed:', importResults.success ? 'SUCCESS' : 'FAILED');
    }

    // Log the import operation
    console.log(`Data import completed by ${user.email || user.name}:`, {
      filename: req.file.originalname,
      type: scriptType,
      totalImported: importResults.totalImported || 'N/A',
      success: importResults.success
    });

    res.status(200).json({
      success: importResults.success,
      data: {
        filename: req.file.originalname,
        type: scriptType,
        importResults,
        preRestoreBackup: preRestoreBackup ? {
          filename: preRestoreBackup.filename,
          timestamp: preRestoreBackup.timestamp
        } : null,
        validation,
        executedAt: new Date().toISOString(),
        executedBy: user.email || user.name
      }
    });
    
  } catch (error) {
    console.error('Error importing script:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to import script',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// GET /api/backup/database-info
// Get database information and statistics
router.get('/database-info', authenticateToken, async (req, res) => {
  try {
    const user = req.user;
    if (!isAdmin(user)) {
      return res.status(403).json({
        success: false,
        message: 'Admin access required'
      });
    }

    const stats = await getDatabaseStats();
    const version = getCurrentVersion();
    
    // Get MongoDB version and connection info
    const mongoInfo = {
      version: mongoose.version,
      connectionState: mongoose.connection.readyState,
      host: mongoose.connection.host,
      port: mongoose.connection.port,
      name: mongoose.connection.name
    };
    
    res.status(200).json({
      success: true,
      data: {
        appVersion: version,
        timestamp: new Date().toISOString(),
        mongodb: mongoInfo,
        collections: stats,
        totalDocuments: Object.values(stats).reduce((sum, stat) => sum + (stat.count || 0), 0),
        availableFormats: ['mongodb', 'json']
      }
    });
    
  } catch (error) {
    console.error('Error getting database info:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to retrieve database information',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// POST /api/backup/validate-compatibility
// Validate backup compatibility with current environment
router.post('/validate-compatibility', [
  authenticateToken,
  body('backupVersion').notEmpty().withMessage('Backup version is required'),
  body('backupData').optional().isObject().withMessage('Backup data must be an object')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const user = req.user;
    if (!isAdmin(user)) {
      return res.status(403).json({
        success: false,
        message: 'Admin access required'
      });
    }

    const { backupVersion, backupData } = req.body;
    const currentVersion = getCurrentVersion();
    const currentStats = await getDatabaseStats();
    
    const compatibility = {
      isCompatible: true,
      warnings: [],
      errors: [],
      recommendations: []
    };
    
    // Version compatibility check
    const backupVersionNum = parseFloat(backupVersion.replace(/[^\d.]/g, ''));
    const currentVersionNum = parseFloat(currentVersion.replace(/[^\d.]/g, ''));
    
    if (backupVersionNum > currentVersionNum) {
      compatibility.errors.push(`Backup version ${backupVersion} is newer than current app version ${currentVersion}`);
      compatibility.isCompatible = false;
    }
    
    if (backupVersionNum < 1.0) {
      compatibility.warnings.push('Backup from pre-1.0 version may have compatibility issues');
    }
    
    // Schema compatibility check
    if (backupData && backupData.metadata && backupData.metadata.statistics) {
      const backupStats = backupData.metadata.statistics;
      
      for (const [collection, backupStat] of Object.entries(backupStats)) {
        const currentStat = currentStats[collection];
        
        if (!currentStat) {
          compatibility.warnings.push(`Collection ${collection} from backup not found in current schema`);
          continue;
        }
        
        // Check for missing fields
        if (backupStat.schema && currentStat.schema) {
          const missingFields = backupStat.schema.filter(field => !currentStat.schema.includes(field));
          if (missingFields.length > 0) {
            compatibility.warnings.push(`Collection ${collection} backup contains fields not in current schema: ${missingFields.join(', ')}`);
          }
        }
      }
    }
    
    // Add recommendations
    if (compatibility.warnings.length > 0) {
      compatibility.recommendations.push('Test restoration in a development environment first');
    }
    
    if (compatibility.errors.length === 0 && compatibility.warnings.length === 0) {
      compatibility.recommendations.push('Backup appears fully compatible with current environment');
    }
    
    res.status(200).json({
      success: true,
      data: {
        compatibility,
        currentVersion,
        backupVersion,
        currentEnvironment: {
          mongodb: mongoose.version,
          node: process.version,
          collections: Object.keys(currentStats)
        }
      }
    });
    
  } catch (error) {
    console.error('Error validating compatibility:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to validate compatibility',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

module.exports = router; 